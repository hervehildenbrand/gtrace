// Package trace implements traceroute functionality using various protocols.
package trace

// NATType indicates the type of NAT behavior detected.
type NATType int

const (
	// NATTypeUnknown indicates NAT detection could not determine type
	NATTypeUnknown NATType = iota

	// NATTypeIPRewrite indicates IP ID field rewriting was detected
	NATTypeIPRewrite

	// NATTypePortRewrite indicates source port rewriting was detected
	NATTypePortRewrite

	// NATTypeTTLAnomaly indicates TTL inconsistency suggesting NAT
	NATTypeTTLAnomaly
)

// NATInfo contains NAT detection results for a hop.
type NATInfo struct {
	// Detected indicates whether NAT was detected at this hop
	Detected bool

	// Type indicates the type of NAT behavior observed
	Type NATType

	// Confidence is a 0-100 score indicating detection confidence
	Confidence int
}

// String returns a formatted string for NAT display.
func (n NATInfo) String() string {
	if !n.Detected {
		return ""
	}
	return "[NAT]"
}

// IPIDMaxSequentialGap is the maximum gap between IP IDs that's still considered sequential.
// Some packet loss or reordering can cause small gaps.
const IPIDMaxSequentialGap = 100

// DetectNATFromIPID analyzes IP ID values to detect NAT.
// NAT devices often rewrite IP ID fields, causing non-sequential IDs.
// Returns true if NAT is likely based on IP ID pattern analysis.
func DetectNATFromIPID(ipIDs []uint16) bool {
	if len(ipIDs) < 2 {
		return false
	}

	// Check for all-zeros pattern (common in firewalls/NAT)
	allZeros := true
	for _, id := range ipIDs {
		if id != 0 {
			allZeros = false
			break
		}
	}
	if allZeros {
		return true
	}

	// Check if IDs are sequential (normal behavior without NAT)
	sequentialCount := 0
	for i := 1; i < len(ipIDs); i++ {
		if IPIDIsSequential(ipIDs[i-1], ipIDs[i]) {
			sequentialCount++
		}
	}

	// If most IDs are not sequential, likely NAT
	totalPairs := len(ipIDs) - 1
	sequentialRatio := float64(sequentialCount) / float64(totalPairs)

	// If less than 50% are sequential, consider it NAT
	return sequentialRatio < 0.5
}

// IPIDIsSequential checks if two IP IDs appear to be sequential.
// Handles uint16 wraparound and allows small gaps.
func IPIDIsSequential(id1, id2 uint16) bool {
	// Calculate forward distance (handling wraparound)
	var diff uint16
	if id2 >= id1 {
		diff = id2 - id1
	} else {
		// Wraparound case: id2 < id1
		diff = (65535 - id1) + id2 + 1
	}

	return diff <= IPIDMaxSequentialGap
}

// DetectNATFromTTL checks if TTL values suggest NAT by comparing
// expected TTL with actual received TTL.
// NAT devices may replace packets entirely, using their own default TTL.
func DetectNATFromTTL(expectedTTL, actualTTL int) bool {
	if expectedTTL <= 0 || actualTTL <= 0 {
		return false
	}

	// Calculate the difference
	diff := expectedTTL - actualTTL

	// Small differences (0-5) are normal from routing
	if diff >= -5 && diff <= 5 {
		return false
	}

	// Check if actualTTL looks like a fresh default from a different OS
	// This suggests the packet was regenerated by NAT
	defaults := CommonTTLDefaults()
	for _, defaultTTL := range defaults {
		// If actual TTL is close to a default, it might be NAT
		if actualTTL >= defaultTTL-10 && actualTTL <= defaultTTL {
			// But only if it's significantly different from expected
			if expectedTTL < defaultTTL-15 || expectedTTL > defaultTTL+5 {
				return true
			}
		}
	}

	return false
}

// CommonTTLDefaults returns common OS default TTL values.
func CommonTTLDefaults() []int {
	return []int{
		64,  // Linux, macOS, FreeBSD, iOS, Android
		128, // Windows
		255, // Cisco IOS, Solaris, some network equipment
		32,  // Some embedded devices (legacy)
	}
}

// GuessOSFromTTL attempts to guess the operating system based on TTL.
func GuessOSFromTTL(ttl int) string {
	switch {
	case ttl <= 32:
		return "embedded/legacy"
	case ttl <= 64:
		return "Linux/macOS/BSD"
	case ttl <= 128:
		return "Windows"
	case ttl <= 255:
		return "Cisco/Solaris"
	default:
		return "unknown"
	}
}

// NATDetectionConfig holds configuration for NAT detection.
type NATDetectionConfig struct {
	// EnableIPIDTracking enables IP ID field analysis
	EnableIPIDTracking bool

	// EnableTTLAnalysis enables TTL-based NAT detection
	EnableTTLAnalysis bool

	// MinSamplesForDetection is the minimum number of samples needed
	MinSamplesForDetection int
}

// DefaultNATDetectionConfig returns sensible defaults.
func DefaultNATDetectionConfig() *NATDetectionConfig {
	return &NATDetectionConfig{
		EnableIPIDTracking:     true,
		EnableTTLAnalysis:      true,
		MinSamplesForDetection: 3,
	}
}
